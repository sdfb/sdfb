<!DOCTYPE html>
<style>
body {
  height: 100vh;
  width: 100vw;
}

svg {
  border: 1px solid black;
  width: 100%;
  height: 100%;
}

.link {
  fill: none;
  stroke: #434055;
  opacity: 0.75;
}

.node {
  fill: #EFF1F4;
  stroke: #78729F;
  stroke-width: 0.75px;
  transition: transform 0.25s ease-in-out;
  cursor: pointer;
}

.node.member {
  fill: #78729F;
  stroke: white;
}

.node:hover {}

.label {
  pointer-events: none;
}

.label text {
  text-anchor: middle;
}

.label rect {
  fill: white;
  stroke: #78729F;
}

.label.not-visible {
  display: none;
}

.label.temporary-unhidden {
  display: block;
}

.faded {
  opacity: 0.2;
}

.link.faded {
  opacity: 0;
}

</style>
<svg id="single-group"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
<script>
var svg = d3.select("svg"),
  // width = +svg.attr("width"),
  width = svg.node().getBoundingClientRect().width,
  chartWidth = width,
  // height = +svg.attr("height"),.
  height = svg.node().getBoundingClientRect().height

var nodes = [];
var links = [];
var members = [];

var simulation = d3.forceSimulation(nodes)

  // set the center of the force layout, this schould not influence the general force field
  .force("center", d3.forceCenter(width / 2, height / 2))

  // attract all the nodes to the center of the svg
  // this result in a force that is summed up to the others
  // helpfull when you don't want nodes to be pushed outside the svg borders, since it LIMITS this behaviour
  .force("x", d3.forceX(width / 2))
  .force("y", d3.forceY(height / 2))

  // A force node employ among each others.
  // If the strength is negative, it results in a repulsion, if positive in an attraction
  // In this case we want node to repel themselves and then to attract depending on the connections they have in between each others
  .force("charge", d3.forceManyBody().strength(-300))

  // the force calculated depending on the nodes connections
  // it is possible to calculate the strength in this way: .strength(function(d){ return sizeEdge(d.weight)*0.35 })
  .force("link", d3.forceLink(links).id(function(d) { return d.id }).iterations(1))

  // Anti collision force
  // fed with the radious of the nodes (even if we're now using sqaures) incremented by 1, to leave a little breathe between nodes
  // Pay attention in using this: it makes the graph less cluttered, but it affect the truthfulness of the force layout.
  // A good strategy could be to not use this untill you're satisfacted by the concatenation of the previous forces
  // and then apply this just to be sure node are not overlapping. Indeed, in graphs, the position of the nodes should not depend
  // on the anticollision algorithm, but on the other forces you put on the canvas.
  // The risk is otherwise to depict something that is not totally true.
  .force("collide", d3.forceCollide(function(d) { return sizeScale(d.attributes.degree) + 1 }).iterations(0))
  // general force settings
  .alpha(1)
  .alphaDecay(0.05)
  .on("tick", ticked)

svg.append("rect")
  .attr("width", width)
  .attr("height", height)
  .style("fill", "none")
  .style("pointer-events", "all")
  .call(d3.zoom()
    .scaleExtent([1 / 2, 4])
    .on("zoom", zoomed))
  .on("click", function() {
    d3.selectAll('#single-group .node, #single-group g.label, #single-group .link').classed('faded', false);
    // update selction and trigger event for other directives
    // scope.currentSelection = {};
    // scope.$apply(); // no need to trigger events, just apply
  })

function zoomed() {
  g.attr("transform", d3.event.transform);
}

var g = svg.append("g").attr("transform", "translate(" + (width / 2) * 0 + "," + (height / 2) * 0 + ")"),
  link = g.append("g").selectAll(".link"),
  node = g.append("g").selectAll(".node");

var label = g.append("g").attr("class", "labels").selectAll(".label");



var sizeScale = d3.scaleLinear()
  .range([8, 30]);

var sizeEdge = d3.scaleLinear()
  .range([1, 10]);

function update(json, onlyMembers) {

  var startTime = d3.now();

  // Format data
  members = [];
  members = json.data.attributes.primary_people;
  nodes = [];
  links = [];
  var excludedNodes = [];
  if (onlyMembers) {
    // console.log('tot nodes:',json.included.length);
    nodes = _.intersectionWith(json.included, members, function(a, b) {
      return a.id == b;
    });
    nodes.forEach(function(n){
    	n['membership'] = true;
    })
    var noMemberNodes = _.differenceWith(json.included, members, function(a, b) {
      return a.id == b;
    });
    // console.log('members:',nodes.length,'- noMembers:', noMemberNodes.length);

    json.data.attributes.connections.forEach(function(l) {
      links.push({
        'type': l.type,
        'source': l.attributes.source,
        'target': l.attributes.target,
        'weight': l.attributes.weight
      })
    })
    // console.log('links', links.length)
    var linksToMembers = [];
    nodes.forEach(function(n1) {
      nodes.forEach(function(n2) {
        links.forEach(function(l) {
          if (l.source == n1.id && l.target == n2.id) {
            linksToMembers.push(l);
          } else if (l.source == n2.id && l.target == n1.id) {
            linksToMembers.push(l);
          }
        })
      })
    })

    // console.log('links between members',linksToMembers.length)
    links = linksToMembers;
  } else {
    nodes = json.included;
    members.forEach(function(m) {
      nodes.forEach(function(n) {
        n['membership'] = false;
        if (n.id == m) {
          n['membership'] = true;
        }
      })
    })
    json.data.attributes.connections.forEach(function(l) {
      links.push({
        'type': l.type,
        'source': l.attributes.source,
        'target': l.attributes.target,
        'weight': l.attributes.weight
      })
    })
  }

  var maxDegree = d3.max(nodes, function(d) { return d.attributes.degree; });
  var minDegree = d3.min(nodes, function(d) { return d.attributes.degree; });
  sizeScale.domain([minDegree, maxDegree]);


  var minWeight = d3.min(links, function(d) { return d.weight });
  var maxWeight = d3.max(links, function(d) { return d.weight });

  sizeEdge.domain([minWeight, maxWeight]);

  // draw things
  function drawGraph() {
    // Apply the general update pattern to the nodes.

    nodes.sort(function(x, y) {
      return (x.membership === y.membership) ? 0 : x ? -1 : 1;
    });

    // nodes.sort(function(x, y) {
    //   return d3.descending(x.attributes.degree, y.attributes.degree);
    // })

    nodes.reverse();
    node = node.data(nodes, function(d) { return d.id; });
    node.exit().remove();
    node = node.enter().append("circle")
      .merge(node)
      .attr("class", "node")
      .classed('member', function(d) {
        return members.filter(function(e) { return e == d.id; }).length > 0;
      })
      .attr("r", function(d) { return sizeScale(d.attributes.degree); })
      .on("click", function(d) {
        toggleClick(d, this);
      })
      // On hover, display label
      .on('mouseenter', function(d) {
        d3.selectAll('g.label').each(function(e) {
          if (e.id == d.id) {
            d3.select(this)
              .classed('temporary-unhidden', true);
          }
        })
        // sort elements so to bring the hovered one on top and make it readable.
        svg.selectAll("g.label").each(function(e, i) {
          if (d == e) {
            var myElement = this;
            d3.select(myElement).remove();
            d3.select('.labels').node().appendChild(myElement);
          }
        })
      })
      .on('mouseleave', function(d) {
        d3.selectAll('g.label').each(function(e) {
          if (e.id == d.id) {
            d3.select(this).classed('temporary-unhidden', false);
          }
        })
      })

    // Apply the general update pattern to the links.
    link = link.data(links, function(d) { return d.source.id + "-" + d.target.id; });
    link.exit().remove();
    link = link.enter().append("path")
      .merge(link)
      .attr("class", "link")
    // .attr("stroke-width", function(d) { return sizeEdge(d.weight) })


    label = label.data(nodes, function(d) { return d.id; });
    label.exit().remove();
    label = label.enter().append("g")
      .merge(label)
      .attr("class", "label")
      .classed("not-visible", function(d, i) {
        return (i <= 10) ? false : true
      })

    label.append('rect')

    label.append('text')
      .text(function(d) {
        return d.attributes.name;
      })

    // Get the Bounding Box of the text created
    d3.selectAll('.label text').each(function(d, i) {
      if (!d.labelBBox) {
        d.labelBBox = this.getBBox();
      }
    });

    // adjust the padding values depending on font and font size
    var paddingLeftRight = 4;
    var paddingTopBottom = 0;

    // set dimentions and positions of rectangles depending on the BBox exctracted before
    d3.selectAll(".label rect")
      .attr("x", function(d) {
        return 0 - d.labelBBox.width / 2 - paddingLeftRight / 2;
      })
      .attr("y", function(d) {
        return 0 + 3 - d.labelBBox.height + paddingTopBottom / 2;
      })
      .attr("width", function(d) {
        return d.labelBBox.width + paddingLeftRight;
      })
      .attr("height", function(d) {
        return d.labelBBox.height + paddingTopBottom;
      });
  }

  drawGraph();

  // Update and restart the simulation.
  simulation.nodes(nodes);
  simulation.force("link").links(links);
  simulation.alpha(1).restart();

  simulation.on("end", function() {
    var endTime = d3.now();
    console.log('Spatialization completed in', (endTime - startTime) / 1000, 'sec.');
  })
}

function dragstarted(d) {
  simulation.restart();
  simulation.alpha(1.0);
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
  simulation.alpha(1.0);
}

function dragended(d) {
  d.fx = null;
  d.fy = null;
}

function ticked() {
  node.attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })

  link.attr("d", function(d) {
    return linkArc(d);
  })

  // Position labels in center of nodes
  label.attr("transform", function(d) {
    return "translate(" + (d.x) + "," + (d.y) + ")"
  })

  if (simulation.alpha() < 0.007 && simulation.force("collide").iterations() == 0) {
    simulation.force("collide").iterations(1).radius(function(d) { return sizeScale(d.attributes.degree) + 1 });
  }

}

// Draw curved edges, create d-value for link path
function linkArc(d) {
  var dx = d.target.x - d.source.x,
    dy = d.target.y - d.source.y,
    dr = Math.sqrt(dx * dx + dy * dy); //Pythagoras!
  return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
}

function toggleClick(d, selectedElement) {
  console.log(d, selectedElement);
  //Handler for when a node is clicked
  if (d.type == "person") {

    // Fade everything
    d3.selectAll('#single-group .node, #single-group g.label, #single-group .link').classed('faded', true);

    // Unfade relevant things
    d3.select(selectedElement).classed('faded', false);
    d3.selectAll('#single-group g.label').filter(function(e) {
      return e.id == d.id;
    }).classed('faded', false);

    // Find connected groups and unfade them
    links.forEach(function(l) {
      // console.log(l.source.id, l.target.id);
      if (d.id == l.source.id) {
        d3.selectAll('#single-group .node, #single-group .label').filter(function(e) {
          return e.id == l.target.id
        }).classed('faded', false);
      } else if (d.id == l.target.id) {
        d3.selectAll('#single-group .node, #single-group .label').filter(function(e) {
          return e.id == l.source.id
        }).classed('faded', false);
      }
    })

    // Find Connected edges and unfade them
    d3.selectAll('#single-group .link').filter(function(e) {
      return e.source.id == d.id || e.target.id == d.id;
    }).classed('faded', false);


    // // This triggers events in groupsbar.js and contextualinfopanel.js when a selection happens
    // scope.currentSelection = d;
    // scope.$broadcast('selectionUpdated', scope.currentSelection);

  }
}

d3.json('groupnetwork.json', function(err, json) {
  if (err) {
    console.error(err);
  }
  update(json, false);
})

</script>
